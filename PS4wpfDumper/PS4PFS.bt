//--------------------------------------
//--- 010 Editor v6.0.2 Binary Template
//
// File: PS4PFS.bt
// Author:
// Revision:
// Purpose:
//--------------------------------------
LittleEndian();

typedef union {
    time_t time;
    uint64 time_64;
} time_t64;

typedef struct {
    int16 mode;
    int16 nlink;
    int32 unk;
    int64 size;
    int64 size2;
    struct { 
        time_t64 unk1_tv_sec;
        time_t64 unk2_tv_sec;
        time_t64 unk3_tv_sec;
        time_t64 unk4_tv_sec; 
        uint32 unk1_tv_nsec;
        uint32 unk2_tv_nsec;
        uint32 unk3_tv_nsec;
        uint32 unk4_tv_nsec;
    } times;
    int32 uid;
    int32 gid;
    int64 unk2[2];
    int64 blocks;
    int64 db[12];
    int64 ib[5];
} di_d64;
typedef struct {
    int16 mode;
    int16 nlink;
    int32 unk;
    int64 size;
    int64 size2;
    struct { 
        time_t64 unk1_tv_sec;
        time_t64 unk2_tv_sec;
        time_t64 unk3_tv_sec;
        time_t64 unk4_tv_sec; 
        uint32 unk1_tv_nsec;
        uint32 unk2_tv_nsec;
        uint32 unk3_tv_nsec;
        uint32 unk4_tv_nsec;
    } times;
    int32 uid;
    int32 gid;
    int64 unk2[2];
    int64 blocks;
    struct { byte sig[32]; int64 block; } db[12];
    struct { byte sig[32]; int64 block; } ib[5];
} di_s64;

typedef struct {
    int64 unk[5];
} idxBlockDescriptor;

typedef struct {
    uint16 o_read : 1;
    uint16 o_write : 1;
    uint16 o_execute : 1;
    uint16 g_read : 1;
    uint16 g_write : 1;
    uint16 g_execute : 1;
    uint16 u_read : 1;
    uint16 u_write : 1;
    uint16 u_execute : 1;
    uint16 unk : 5;
    uint16 dir : 1;
    uint16 file : 1;
} ino_mode;
typedef struct {
    ino_mode mode;
    uint16 nlink;
    struct {
        uint compressed : 1;
        uint unk0 : 1;
        uint unk1 : 1;
        uint unk2 : 1;
        uint readonly : 1;
        uint unk3 : 12;
        uint internal : 1;
    } flags;
    uint64 size;
    uint64 size_compressed;
    struct { 
        time_t64 unk1_tv_sec;
        time_t64 unk2_tv_sec;
        time_t64 unk3_tv_sec;
        time_t64 unk4_tv_sec; 
        uint32 unk1_tv_nsec;
        uint32 unk2_tv_nsec;
        uint32 unk3_tv_nsec;
        uint32 unk4_tv_nsec;
    } times;
    uint32 uid;
    uint32 gid;
    uint64 unk2[2];
    uint32 blocks;
    struct {
        int blockno;
    } db[12];
    struct {
        uint32 blockno;
    } ib[5];
} di_d32 <read=DID32READ>;

typedef struct {
    ino_mode mode;
    uint16 nlink;
    struct {
        uint compressed : 1;
        uint unk0 : 1;
        uint unk1 : 1;
        uint unk2 : 1;
        uint readonly : 1;
        uint unk3 : 12;
        uint internal : 1;
    } flags;
    uint64 size;
    uint64 size_compressed;
    struct { 
        time_t64 unk1_tv_sec;
        time_t64 unk2_tv_sec;
        time_t64 unk3_tv_sec;
        time_t64 unk4_tv_sec; 
        uint32 unk1_tv_nsec;
        uint32 unk2_tv_nsec;
        uint32 unk3_tv_nsec;
        uint32 unk4_tv_nsec;
    } times;
    uint32 uid;
    uint32 gid;
    uint64 unk2[2];
    uint32 blocks;
    struct {
        char sig[32];
        int blockno;
    } db[12];
    struct {
        char sig[32];
        uint32 blockno;
    } ib[5];
} di_s32 <read=DIS32READ>;

string DID32READ( di_d32 &m )
{
 char outbuf[100];
 
 SPrintf(outbuf, "%s, size %u (%u blocks) start %x", 
    m.mode.dir ? "Directory" : "File", m.size, m.blocks, m.db[0].blockno);
 return outbuf;
}
string DIS32READ( di_s32 &m )
{
 char outbuf[100];
 
 SPrintf(outbuf, "%s, size %u (%u blocks) start %x", 
    m.mode.dir ? "Directory" : "File", m.size, m.blocks, m.db[0].blockno);
 return outbuf;
}



// modes:
// 0x8 : read-only
// 0x4 : compressed
// 0x2 : ??
// 0x1 : encrypted

typedef struct {
    local int start = FTell();
    int64 version; // 1
    int64 magic; // 20130305 (march 5 2013???)
    int32 id[2];
    uchar fmode;
    uchar clean;
    uchar ronly;
    uchar rsv;
    struct {
        uint16 is_signed : 1;
        uint16 is_64_bit : 1;
        uint16 encrypted: 1;
        uint16 unk_always_1 : 1;
        uint16 unk : 12;
    } mode;
    int16 unk1;
    int32 blocksz;
    int32 nbackup;
    int64 nblock;
    int64 dinodeCount; // changes
    int64 ndblock; // changes
    int64 dinodeBlockCount; // changes
    int64 zero;
    di_s64 superroot_ino;
    FSeek(start + 0x36C);
    int unk_index;
    byte crypt_seed[16];
    byte unk_digest[32];
    byte superblock_sig[256];
    byte fs_img_sig[256];
} PFS_HDR;


typedef struct {
    local int64 start = FTell();
    int32 ino;
    int32 type;
    int32 namelen;
    int32 entsize;
    char name[];
    if((FTell() & 7) != 0)
        char space[(FTell() + 7 & (~7)) - FTell()];
    FSeek(start + entsize);
} dirent<read=DIRENTRD>;

string DIRENTRD(dirent& di){
    return di.name;
}
typedef struct {
    int32 dib_num;
    int32 numdirs;
} dirent_block;

typedef struct {
    local int offset = FTell();
    PFS_HDR header;
    //idxBlockDescriptor blocks[header.dinodeBlockCount];
    FSeek(offset + header.blocksz);
    local int numDirs;
    local int total;
    if(header.mode.encrypted) {
        FSeek(offset + header.blocksz);
        local uint64 data_length = (uint64)header.blocksz * (uint64)(header.ndblock - 1);
        char encrypted_data[1];
    } else {
        struct dinode_block {
            local int maxPerSector = header.blocksz / sizeof(di_d32);
            local int i;
            local int j;
            total = 0;
            for(i = 0; i < header.dinodeBlockCount; i++) {
                FSeek(offset + header.blocksz + header.blocksz * i);
                for(j = 0; j < maxPerSector && total < header.dinodeCount; j++){
                    if(header.mode.is_signed){
                        di_s32 dinode;
                    } else {
                        di_d32 dinode;
                    }
                    if(dinode[i].mode.dir) numDirs++;
                    total++;
                }
            }
        } dinodes;
        if(header.mode.is_signed) {
            local int i;
            local int j;
            local int k;
            for(i = 0; i < total; i++){
                struct {
                    for(j = 0; j < 5; j++){
                        if(dinodes.dinode[i].ib[j].blockno == 0) break;
                        FSeek(header.blocksz * dinodes.dinode[i].ib[j].blockno);
                        for(k = 0; k < header.blocksz; k += 36) {
                            if(ReadInt64() == 0){
                                break;
                            }
                            struct {
                                char sig[32];
                                int block;
                            } indirect_block;
                        }
                    }
                } inode_ibs;
            }
        }
        
        FSeek(offset + header.blocksz * dinodes.dinode[0].db[0].blockno);
        local int min_size = 280;
        struct {
            local int i;
            local int cont;
            local int blocks;
            for(i =0; i< header.dinodeCount; i++) {
                if((dinodes.dinode[i].mode.dir) != 1) continue;
                FSeek(offset + header.blocksz * dinodes.dinode[i].db[0].blockno);
                
                cont = true;
                  while(cont == true){
                    dirent d<optimize=false>;
                    
                    cont = d.ino != 0;
                  }
            }
        } dirent_blocks;
    } // not encrypted
} PFS_IMAGE;

if(FTell() == 0) {
    PFS_IMAGE image;
}
